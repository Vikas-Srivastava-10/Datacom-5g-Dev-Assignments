<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>5G NR Physical Layer Scrambling - Gold Sequence Deep Dive</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            /* Modern Color Palette */
            --bg-body: #0a0e27;
            --bg-card: #151b3d;
            --purple-primary: #a855f7;
            --cyan-secondary: #06b6d4;
            --magenta-accent: #ec4899;
            --teal-highlight: #14b8a6;
            --orange-warning: #f59e0b;
            --green-success: #22c55e;
            --text-main: #f8fafc;
            --text-dim: #94a3b8;
            --border: #1e293b;
            --accent-glow: rgba(168, 85, 247, 0.25);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f4d 100%);
            color: var(--text-main);
            font-family: 'Inter', sans-serif;
            line-height: 1.8;
            padding-bottom: 50px;
            min-height: 100vh;
        }

        /* Enhanced Header */
        header {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.1) 0%, rgba(6, 182, 212, 0.1) 100%);
            padding: 40px 40px;
            border-bottom: 2px solid var(--purple-primary);
            text-align: center;
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(168, 85, 247, 0.1) 0%, transparent 70%);
            animation: rotate 20s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .logo { 
            font-weight: 800; 
            font-size: 2.2rem; 
            background: linear-gradient(135deg, var(--purple-primary) 0%, var(--cyan-secondary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -1.5px;
            position: relative;
            z-index: 1;
        }
        
        .logo span { 
            background: linear-gradient(135deg, #fff 0%, var(--text-dim) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 400;
        }
        
        .header-desc { 
            color: var(--text-dim); 
            font-size: 1rem; 
            margin-top: 10px;
            position: relative;
            z-index: 1;
        }

        .container { max-width: 1300px; margin: 0 auto; padding: 25px; }

        /* Navigation Tabs */
        .tabs {
            display: flex;
            gap: 15px;
            margin: 30px 0 50px 0;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 20px;
            position: sticky;
            top: 20px;
            z-index: 1000;
            box-shadow: 0 15px 40px rgba(0,0,0,0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tab-btn {
            flex: 1;
            padding: 16px;
            border: none;
            background: transparent;
            color: var(--text-dim);
            cursor: pointer;
            font-weight: 700;
            border-radius: 12px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 0.95rem;
            position: relative;
        }

        .tab-btn::before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 3px;
            background: currentColor;
            transition: width 0.3s ease;
        }

        .tab-btn:hover::before {
            width: 80%;
        }

        .tab-btn.active[data-target="overview"] { 
            background: linear-gradient(135deg, var(--purple-primary) 0%, #9333ea 100%); 
            color: white; 
            box-shadow: 0 0 25px var(--purple-primary); 
        }
        .tab-btn.active[data-target="gold"] { 
            background: linear-gradient(135deg, var(--cyan-secondary) 0%, #0891b2 100%); 
            color: white; 
            box-shadow: 0 0 25px var(--cyan-secondary); 
        }
        .tab-btn.active[data-target="architecture"] { 
            background: linear-gradient(135deg, var(--magenta-accent) 0%, #db2777 100%); 
            color: white; 
            box-shadow: 0 0 25px var(--magenta-accent); 
        }
        .tab-btn.active[data-target="code"] { 
            background: linear-gradient(135deg, var(--teal-highlight) 0%, #0d9488 100%); 
            color: white; 
            box-shadow: 0 0 25px var(--teal-highlight); 
        }

        /* Content Sections */
        .section { display: none; animation: fadeIn 0.6s ease-out; }
        .section.active { display: block; }

        @keyframes fadeIn { 
            from { opacity: 0; transform: translateY(30px); } 
            to { opacity: 1; transform: translateY(0); } 
        }

        .grid-layout { 
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 35px; 
            align-items: start; 
        }
        
        @media (max-width: 900px) { 
            .grid-layout { grid-template-columns: 1fr; } 
            .tabs { flex-direction: column; }
        }

        .info-card {
            background: linear-gradient(135deg, var(--bg-card) 0%, rgba(21, 27, 61, 0.8) 100%);
            padding: 35px;
            border-radius: 25px;
            border: 1px solid var(--border);
            height: 100%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .info-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.7);
        }

        .tag {
            display: inline-block;
            padding: 6px 16px;
            background: rgba(168, 85, 247, 0.2);
            color: var(--purple-primary);
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 15px;
            border: 1px solid var(--purple-primary);
        }

        h2 {
            font-size: 2rem;
            margin-bottom: 20px;
            background: linear-gradient(135deg, var(--purple-primary) 0%, var(--cyan-secondary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        h3 {
            font-size: 1.4rem;
            color: var(--cyan-secondary);
            margin: 25px 0 15px 0;
        }

        p {
            color: var(--text-dim);
            margin-bottom: 15px;
            font-size: 1.05rem;
        }

        /* LFSR Visualization */
        .lfsr-container {
            background: rgba(0, 0, 0, 0.5);
            padding: 30px;
            border-radius: 15px;
            margin: 30px 0;
            border: 2px solid var(--purple-primary);
        }

        .lfsr-title {
            text-align: center;
            color: var(--purple-primary);
            font-weight: 700;
            font-size: 1.2rem;
            margin-bottom: 20px;
        }

        .lfsr-register {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .lfsr-bit {
            width: 35px;
            height: 35px;
            background: linear-gradient(135deg, var(--purple-primary), var(--magenta-accent));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: white;
            font-family: 'JetBrains Mono', monospace;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .lfsr-bit:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 20px rgba(168, 85, 247, 0.5);
        }

        .lfsr-bit.zero {
            background: linear-gradient(135deg, #374151, #1f2937);
        }

        .tap-indicator {
            position: relative;
        }

        .tap-indicator::after {
            content: '⊕';
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--orange-warning);
            font-size: 1.2rem;
            font-weight: 700;
        }

        /* XOR Operation Visualization */
        .xor-demo {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .bit-value {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, var(--cyan-secondary), var(--teal-highlight));
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            font-weight: 800;
            color: white;
            box-shadow: 0 5px 20px rgba(6, 182, 212, 0.4);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .xor-symbol {
            font-size: 2.5rem;
            color: var(--orange-warning);
            font-weight: 700;
        }

        /* Architecture Flow */
        .architecture-flow {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 25px;
            margin: 40px 0;
            flex-wrap: wrap;
        }

        .flow-box {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.1) 0%, rgba(6, 182, 212, 0.1) 100%);
            padding: 30px 35px;
            border-radius: 20px;
            border: 2px solid var(--purple-primary);
            min-width: 180px;
            text-align: center;
            position: relative;
            transition: all 0.3s ease;
        }

        .flow-box:hover {
            transform: scale(1.05);
            border-color: var(--cyan-secondary);
            box-shadow: 0 0 30px rgba(168, 85, 247, 0.4);
        }

        .flow-box .icon {
            font-size: 3rem;
            margin-bottom: 15px;
            background: linear-gradient(135deg, var(--purple-primary), var(--cyan-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .flow-box h4 {
            color: var(--text-main);
            font-size: 1.1rem;
            margin-bottom: 8px;
        }

        .flow-box p {
            font-size: 0.9rem;
            color: var(--text-dim);
            margin: 0;
        }

        .flow-arrow {
            font-size: 2.5rem;
            color: var(--cyan-secondary);
            animation: flowMove 1.5s infinite;
        }

        @keyframes flowMove {
            0%, 100% { transform: translateX(0); opacity: 1; }
            50% { transform: translateX(10px); opacity: 0.5; }
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .stat-card {
            background: rgba(168, 85, 247, 0.1);
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid var(--purple-primary);
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(168, 85, 247, 0.3);
        }

        .stat-card .value {
            font-size: 2.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, var(--purple-primary), var(--cyan-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .stat-card .label {
            color: var(--text-dim);
            font-size: 0.95rem;
        }

        /* Code Block */
        .code-container {
            background: #0d1117;
            border-radius: 15px;
            overflow: hidden;
            border: 1px solid #30363d;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            margin-top: 20px;
        }

        .code-header {
            background: linear-gradient(135deg, #1a1f36 0%, #2d3748 100%);
            padding: 15px 20px;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .code-header h4 {
            color: var(--text-main);
            font-size: 1rem;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .copy-btn {
            background: var(--purple-primary);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .copy-btn:hover {
            background: var(--magenta-accent);
            transform: translateY(-2px);
        }

        pre {
            margin: 0;
            padding: 25px;
            overflow-x: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            color: #c9d1d9;
        }

        code {
            font-family: 'JetBrains Mono', monospace;
        }

        /* Syntax Highlighting */
        .keyword { color: #ff7b72; }
        .type { color: #79c0ff; }
        .function { color: #d2a8ff; }
        .string { color: #a5d6ff; }
        .comment { color: #8b949e; }
        .number { color: #79c0ff; }

        /* Summary Box */
        .summary {
            background: rgba(168, 85, 247, 0.1);
            padding: 25px;
            border-radius: 15px;
            border-left: 4px solid var(--purple-primary);
            margin: 25px 0;
        }

        .summary b {
            color: var(--purple-primary);
        }

        /* Animation Controls */
        .control-panel {
            background: rgba(0, 0, 0, 0.5);
            padding: 25px;
            border-radius: 15px;
            margin: 30px 0;
            text-align: center;
        }

        .btn {
            background: linear-gradient(135deg, var(--purple-primary), var(--magenta-accent));
            color: white;
            border: none;
            padding: 15px 35px;
            border-radius: 30px;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(168, 85, 247, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        /* Icon Badge */
        .icon-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, var(--purple-primary), var(--magenta-accent));
            border-radius: 15px;
            font-size: 1.8rem;
            color: white;
            margin-bottom: 15px;
            box-shadow: 0 5px 20px rgba(168, 85, 247, 0.4);
        }

        /* Formula Display */
        .formula-box {
            background: rgba(0, 0, 0, 0.5);
            padding: 25px;
            border-radius: 15px;
            border: 2px solid var(--cyan-secondary);
            text-align: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.2rem;
            color: var(--cyan-secondary);
            margin: 20px 0;
        }

        /* Footer */
        footer {
            text-align: center;
            padding: 40px 20px;
            margin-top: 60px;
            border-top: 2px solid var(--border);
            background: rgba(0, 0, 0, 0.3);
        }

        footer p {
            color: var(--text-dim);
            margin: 5px 0;
        }

        /* Table Styles */
        .param-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
        }

        .param-table th {
            background: linear-gradient(135deg, var(--purple-primary), var(--magenta-accent));
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 700;
        }

        .param-table td {
            padding: 12px 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-dim);
        }

        .param-table tr:hover td {
            background: rgba(168, 85, 247, 0.1);
            color: var(--text-main);
        }

        /* Sequence Animation */
        .sequence-viewer {
            background: rgba(0, 0, 0, 0.5);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            font-family: 'JetBrains Mono', monospace;
        }

        .sequence-row {
            display: flex;
            gap: 5px;
            margin: 10px 0;
            align-items: center;
        }

        .sequence-label {
            min-width: 100px;
            color: var(--cyan-secondary);
            font-weight: 700;
        }

        .sequence-bits {
            display: flex;
            gap: 3px;
            flex-wrap: wrap;
        }

        .seq-bit {
            width: 25px;
            height: 25px;
            background: var(--purple-primary);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85rem;
            color: white;
            transition: all 0.3s ease;
        }

        .seq-bit.zero {
            background: #374151;
        }

        .seq-bit:hover {
            transform: scale(1.2);
        }
    </style>
</head>
<body>

<header>
    <div class="logo">5G NR <span>Physical Layer Scrambling</span></div>
    <p class="header-desc">Gold Sequence Generation • 3GPP TS 38.211 §5.2.1 • PBCH Security</p>
</header>

<div class="container">
    <!-- Navigation Tabs -->
    <div class="tabs">
        <button class="tab-btn active" data-target="overview">
            <i class="fas fa-info-circle"></i> Overview
        </button>
        <button class="tab-btn" data-target="gold">
            <i class="fas fa-microchip"></i> Gold Sequence
        </button>
        <button class="tab-btn" data-target="architecture">
            <i class="fas fa-project-diagram"></i> Architecture
        </button>
        <button class="tab-btn" data-target="code">
            <i class="fas fa-code"></i> Implementation
        </button>
    </div>

    <!-- Section 1: Overview -->
    <div id="overview" class="section active">
        <div class="grid-layout">
            <div class="info-card">
                <span class="tag"><i class="fas fa-shield-alt"></i> Security & Randomization</span>
                <h2>Physical Layer Scrambling</h2>
                
                <p>
                    <strong>Physical layer scrambling</strong> is a fundamental security and signal processing technique in 5G New Radio (NR) that applies pseudorandom sequences to transmitted data bits. This critical operation transforms the statistical properties of the signal, making it appear random and noise-like to unintended receivers while maintaining complete recoverability at the legitimate receiver. The scrambling process uses <strong>Gold sequences</strong>—mathematically optimal pseudorandom sequences generated by Linear Feedback Shift Registers (LFSRs)—which provide excellent autocorrelation and cross-correlation properties essential for multi-user wireless systems.
                </p>

                <p>
                    In the 5G NR PBCH (Physical Broadcast Channel), scrambling serves multiple vital purposes: it <strong>randomizes interference patterns</strong> between neighboring cells, prevents systematic DC bias in modulated signals, enhances security by obscuring the actual data content, and ensures uniform spectral characteristics regardless of the information being transmitted. The scrambling operation is performed through a simple but powerful XOR operation between the encoded data bits and a cell-specific Gold sequence. This cell-specificity, determined by the Physical Cell ID (N_ID_cell), ensures that each base station generates a unique scrambling pattern, enabling receivers to distinguish between overlapping transmissions from different cells.
                </p>

                <p>
                    The 5G NR standard defines the scrambling initialization based on both the <strong>Physical Cell ID</strong> and the <strong>SSB index</strong> (v parameter, representing SSB index mod 4), creating a two-dimensional scrambling space. The Gold sequence generator consists of two 31-bit LFSRs with carefully chosen feedback polynomials that guarantee a maximal sequence length of 2³¹-1 bits before repetition. A warm-up period of Nc=1600 cycles plus an offset ensures that the scrambling sequence starts from a well-distributed state. This sophisticated scrambling architecture, standardized in 3GPP TS 38.211 Section 5.2.1, represents decades of cryptographic and signal processing research optimized for the demanding requirements of 5G wireless communications.
                </p>

                <div class="summary">
                    <b><i class="fas fa-key"></i> Core Principle:</b> Scrambling transforms predictable data patterns into pseudorandom sequences through XOR operations with Gold sequences, providing interference randomization, security enhancement, and spectral shaping—all while maintaining perfect reversibility at the receiver using the same cell-specific initialization parameters.
                </div>
            </div>

            <div class="info-card">
                <div style="text-align: center;">
                    <div class="icon-badge pulse">
                        <i class="fas fa-random"></i>
                    </div>
                    <h3 style="color: var(--purple-primary); margin-top: 0;">Scrambling Specifications</h3>
                </div>

                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="value">31</div>
                        <div class="label">LFSR Bits</div>
                    </div>
                    <div class="stat-card">
                        <div class="value">2³¹-1</div>
                        <div class="label">Sequence Length</div>
                    </div>
                    <div class="stat-card">
                        <div class="value">1600</div>
                        <div class="label">Warm-up Cycles</div>
                    </div>
                    <div class="stat-card">
                        <div class="value">XOR</div>
                        <div class="label">Operation</div>
                    </div>
                </div>

                <h3><i class="fas fa-chart-line"></i> Key Benefits</h3>
                <div style="background: rgba(0, 0, 0, 0.3); padding: 20px; border-radius: 12px; margin-top: 15px;">
                    <p style="margin: 10px 0; display: flex; align-items: center; gap: 10px;">
                        <i class="fas fa-check-circle" style="color: var(--green-success);"></i>
                        <strong>Interference Randomization:</strong> Breaks correlation patterns
                    </p>
                    <p style="margin: 10px 0; display: flex; align-items: center; gap: 10px;">
                        <i class="fas fa-check-circle" style="color: var(--green-success);"></i>
                        <strong>Cell Differentiation:</strong> Unique sequences per cell
                    </p>
                    <p style="margin: 10px 0; display: flex; align-items: center; gap: 10px;">
                        <i class="fas fa-check-circle" style="color: var(--green-success);"></i>
                        <strong>DC Bias Removal:</strong> Balanced signal statistics
                    </p>
                    <p style="margin: 10px 0; display: flex; align-items: center; gap: 10px;">
                        <i class="fas fa-check-circle" style="color: var(--green-success);"></i>
                        <strong>Security Layer:</strong> Obscures data patterns
                    </p>
                </div>

                <h3 style="margin-top: 30px;"><i class="fas fa-cog"></i> Initialization Parameters</h3>
                <table class="param-table">
                    <tr>
                        <th>Parameter</th>
                        <th>Description</th>
                        <th>Range</th>
                    </tr>
                    <tr>
                        <td><strong>N_ID_cell</strong></td>
                        <td>Physical Cell ID</td>
                        <td>0 to 1007</td>
                    </tr>
                    <tr>
                        <td><strong>v</strong></td>
                        <td>SSB index mod 4</td>
                        <td>0 to 3</td>
                    </tr>
                    <tr>
                        <td><strong>c_init</strong></td>
                        <td>Scrambler seed</td>
                        <td>= N_ID_cell</td>
                    </tr>
                    <tr>
                        <td><strong>N_c</strong></td>
                        <td>Warm-up offset</td>
                        <td>1600 cycles</td>
                    </tr>
                </table>
            </div>
        </div>
    </div>

    <!-- Section 2: Gold Sequence -->
    <div id="gold" class="section">
        <div class="info-card" style="margin-bottom: 35px;">
            <span class="tag"><i class="fas fa-microchip"></i> LFSR Technology</span>
            <h2>Gold Sequence Generation</h2>
            <p>
                Gold sequences are generated by XORing the outputs of two maximum-length Linear Feedback Shift Registers (m-sequences). The 5G NR standard uses two 31-bit LFSRs with specific feedback polynomials.
            </p>
        </div>

        <div class="grid-layout">
            <div class="info-card">
                <h3><i class="fas fa-microchip"></i> LFSR 1 (x₁ Register)</h3>
                <div class="lfsr-container">
                    <div class="lfsr-title">31-Bit Register • Polynomial: x³¹ + x³ + 1</div>
                    <div class="lfsr-register" id="lfsr1">
                        <!-- Generated by JavaScript -->
                    </div>
                    <div style="text-align: center; margin-top: 15px; color: var(--text-dim);">
                        <p style="margin: 0; font-size: 0.95rem;">
                            Taps at positions <strong style="color: var(--orange-warning);">3</strong> and <strong style="color: var(--orange-warning);">0</strong>
                        </p>
                    </div>
                </div>

                <div class="formula-box" style="margin-top: 25px;">
                    x₁(n+31) = (x₁(n+3) + x₁(n)) mod 2
                </div>

                <div style="background: rgba(6, 182, 212, 0.1); padding: 20px; border-radius: 12px; border: 2px solid var(--cyan-secondary); margin-top: 20px;">
                    <p style="margin: 0; color: var(--text-main);">
                        <strong>Initial State:</strong> x₁(0) = 1, all other bits = 0<br>
                        <strong>Feedback:</strong> XOR of bit positions 3 and 0<br>
                        <strong>Period:</strong> 2³¹ - 1 = 2,147,483,647 bits
                    </p>
                </div>
            </div>

            <div class="info-card">
                <h3><i class="fas fa-microchip"></i> LFSR 2 (x₂ Register)</h3>
                <div class="lfsr-container">
                    <div class="lfsr-title">31-Bit Register • Polynomial: x³¹ + x³ + x² + x + 1</div>
                    <div class="lfsr-register" id="lfsr2">
                        <!-- Generated by JavaScript -->
                    </div>
                    <div style="text-align: center; margin-top: 15px; color: var(--text-dim);">
                        <p style="margin: 0; font-size: 0.95rem;">
                            Taps at positions <strong style="color: var(--orange-warning);">3, 2, 1, 0</strong>
                        </p>
                    </div>
                </div>

                <div class="formula-box" style="margin-top: 25px;">
                    x₂(n+31) = (x₂(n+3) + x₂(n+2) + x₂(n+1) + x₂(n)) mod 2
                </div>

                <div style="background: rgba(236, 72, 153, 0.1); padding: 20px; border-radius: 12px; border: 2px solid var(--magenta-accent); margin-top: 20px;">
                    <p style="margin: 0; color: var(--text-main);">
                        <strong>Initial State:</strong> x₂(0..30) = c_init (N_ID_cell)<br>
                        <strong>Feedback:</strong> XOR of bit positions 3, 2, 1, and 0<br>
                        <strong>Cell-Specific:</strong> Different initialization per cell
                    </p>
                </div>
            </div>
        </div>

        <div class="info-card" style="margin-top: 35px;">
            <h3 style="text-align: center; margin-bottom: 25px;">
                <i class="fas fa-calculator"></i> Gold Sequence Output Calculation
            </h3>

            <div class="xor-demo">
                <div>
                    <p style="text-align: center; color: var(--cyan-secondary); margin-bottom: 10px; font-weight: 700;">x₁ Output</p>
                    <div class="bit-value" id="x1-out">0</div>
                </div>

                <div class="xor-symbol">⊕</div>

                <div>
                    <p style="text-align: center; color: var(--magenta-accent); margin-bottom: 10px; font-weight: 700;">x₂ Output</p>
                    <div class="bit-value" id="x2-out">1</div>
                </div>

                <div class="xor-symbol">=</div>

                <div>
                    <p style="text-align: center; color: var(--green-success); margin-bottom: 10px; font-weight: 700;">Gold Bit</p>
                    <div class="bit-value" id="gold-out" style="background: linear-gradient(135deg, var(--green-success), #16a34a);">1</div>
                </div>
            </div>

            <div class="formula-box" style="font-size: 1.4rem;">
                c(n) = [x₁(n) + x₂(n)] mod 2
            </div>

            <div class="control-panel">
                <button class="btn" onclick="stepLFSR()">
                    <i class="fas fa-step-forward"></i> Step One Bit
                </button>
                <button class="btn" onclick="runLFSR()">
                    <i class="fas fa-play"></i> Run Sequence
                </button>
                <button class="btn" onclick="resetLFSR()">
                    <i class="fas fa-undo"></i> Reset
                </button>
            </div>

            <div class="summary" style="background: rgba(20, 184, 166, 0.1); border-color: var(--teal-highlight); margin-top: 25px;">
                <b><i class="fas fa-lightbulb"></i> Gold Sequence Properties:</b> The XOR combination of two m-sequences creates a family of sequences with optimal autocorrelation (nearly ideal impulse) and cross-correlation (minimal interference between different cell IDs) properties, making them perfect for multi-cell CDMA systems.
            </div>
        </div>
    </div>

    <!-- Section 3: Architecture -->
    <div id="architecture" class="section">
        <div class="info-card" style="margin-bottom: 35px;">
            <span class="tag"><i class="fas fa-sitemap"></i> System Architecture</span>
            <h2>PBCH Scrambling Architecture</h2>

            <div class="architecture-flow">
                <div class="flow-box">
                    <div class="icon"><i class="fas fa-file-alt"></i></div>
                    <h4>Input Bits</h4>
                    <p>Encoded PBCH<br>(864 bits)</p>
                </div>

                <div class="flow-arrow">→</div>

                <div class="flow-box">
                    <div class="icon"><i class="fas fa-cog"></i></div>
                    <h4>Initialize</h4>
                    <p>c_init = N_ID_cell<br>Warm-up: 1600+v·M</p>
                </div>

                <div class="flow-arrow">→</div>

                <div class="flow-box">
                    <div class="icon"><i class="fas fa-microchip"></i></div>
                    <h4>Gold Gen</h4>
                    <p>LFSR1 ⊕ LFSR2<br>Generate c(n)</p>
                </div>

                <div class="flow-arrow">→</div>

                <div class="flow-box">
                    <div class="icon"><i class="fas fa-calculator"></i></div>
                    <h4>XOR</h4>
                    <p>b(i) ⊕ c(i)<br>Scramble bits</p>
                </div>

                <div class="flow-arrow">→</div>

                <div class="flow-box">
                    <div class="icon"><i class="fas fa-broadcast-tower"></i></div>
                    <h4>Output</h4>
                    <p>Scrambled PBCH<br>Ready for TX</p>
                </div>
            </div>

            <div class="summary" style="background: rgba(236, 72, 153, 0.1); border-color: var(--magenta-accent);">
                <b><i class="fas fa-info-circle"></i> Processing Flow:</b> The scrambling process begins with initialization of two LFSRs based on cell ID, followed by a warm-up period, then generates the scrambling sequence bit-by-bit while simultaneously XORing with input data to produce the final scrambled output.
            </div>
        </div>

        <div class="grid-layout">
            <div class="info-card">
                <h3><i class="fas fa-list-ol"></i> Scrambling Algorithm Steps</h3>
                
                <div style="background: rgba(0, 0, 0, 0.3); padding: 25px; border-radius: 15px; margin-top: 20px;">
                    <div style="margin-bottom: 20px;">
                        <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                            <div style="width: 40px; height: 40px; background: linear-gradient(135deg, var(--purple-primary), var(--magenta-accent)); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 800; color: white;">1</div>
                            <h4 style="color: var(--purple-primary); margin: 0;">Initialize LFSRs</h4>
                        </div>
                        <p style="margin-left: 55px; font-size: 0.95rem;">
                            Set x₁ = 0x1 (all zeros except LSB)<br>
                            Set x₂ = c_init = N_ID_cell (masked to 31 bits)
                        </p>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                            <div style="width: 40px; height: 40px; background: linear-gradient(135deg, var(--cyan-secondary), var(--teal-highlight)); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 800; color: white;">2</div>
                            <h4 style="color: var(--cyan-secondary); margin: 0;">Warm-up Phase</h4>
                        </div>
                        <p style="margin-left: 55px; font-size: 0.95rem;">
                            Run LFSRs for N_c + v·M_bit cycles<br>
                            N_c = 1600, v = SSB_index mod 4, M_bit = 864
                        </p>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                            <div style="width: 40px; height: 40px; background: linear-gradient(135deg, var(--magenta-accent), #db2777); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 800; color: white;">3</div>
                            <h4 style="color: var(--magenta-accent); margin: 0;">Generate Sequence</h4>
                        </div>
                        <p style="margin-left: 55px; font-size: 0.95rem;">
                            For each bit position i = 0 to M_bit-1:<br>
                            Compute c(i) = x₁(i) XOR x₂(i)
                        </p>
                    </div>

                    <div>
                        <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                            <div style="width: 40px; height: 40px; background: linear-gradient(135deg, var(--teal-highlight), #0d9488); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 800; color: white;">4</div>
                            <h4 style="color: var(--teal-highlight); margin: 0;">Apply Scrambling</h4>
                        </div>
                        <p style="margin-left: 55px; font-size: 0.95rem;">
                            For each input bit b(i):<br>
                            output(i) = b(i) XOR c(i)
                        </p>
                    </div>
                </div>
            </div>

            <div class="info-card">
                <h3><i class="fas fa-eye"></i> Live Scrambling Demonstration</h3>
                
                <div class="sequence-viewer">
                    <div class="sequence-row">
                        <div class="sequence-label">Input:</div>
                        <div class="sequence-bits" id="input-sequence">
                            <!-- Generated by JavaScript -->
                        </div>
                    </div>
                    
                    <div class="sequence-row">
                        <div class="sequence-label">Gold Seq:</div>
                        <div class="sequence-bits" id="gold-sequence">
                            <!-- Generated by JavaScript -->
                        </div>
                    </div>
                    
                    <div class="sequence-row">
                        <div class="sequence-label">Output:</div>
                        <div class="sequence-bits" id="output-sequence">
                            <!-- Generated by JavaScript -->
                        </div>
                    </div>
                </div>

                <div class="control-panel">
                    <button class="btn" onclick="generateSequences()">
                        <i class="fas fa-sync"></i> Generate New Sequences
                    </button>
                </div>

                <h3 style="margin-top: 30px;"><i class="fas fa-clock"></i> Performance Metrics</h3>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="value">&lt; 2μs</div>
                        <div class="label">Processing Time</div>
                    </div>
                    <div class="stat-card">
                        <div class="value">O(N)</div>
                        <div class="label">Complexity</div>
                    </div>
                </div>

                <div style="background: rgba(245, 158, 11, 0.1); padding: 20px; border-radius: 12px; border-left: 4px solid var(--orange-warning); margin-top: 20px;">
                    <p style="margin: 0; color: var(--text-main);">
                        <i class="fas fa-bolt" style="color: var(--orange-warning);"></i>
                        <strong>Hardware Acceleration:</strong> Modern 5G base stations implement scrambling in dedicated FPGA/ASIC hardware, achieving scrambling rates exceeding 100 Gbps for massive MIMO systems.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Section 4: Code Implementation -->
    <div id="code" class="section">
        <div class="info-card" style="margin-bottom: 35px;">
            <span class="tag"><i class="fas fa-file-code"></i> C++ Implementation</span>
            <h2>Physical Layer Scrambling Source Code</h2>
            <p>
                Complete C++ implementation of the 5G NR PBCH physical layer scrambler with Gold sequence generation conforming to 3GPP TS 38.211 Section 5.2.1. This production-grade code demonstrates the exact algorithm used in commercial 5G infrastructure.
            </p>
        </div>

        <div class="code-container">
            <div class="code-header">
                <h4>
                    <i class="fas fa-file-code"></i>
                    pbch_scrambler.cpp
                </h4>
                <button class="copy-btn" onclick="copyCode()">
                    <i class="fas fa-copy"></i> Copy Code
                </button>
            </div>
            <pre id="code-block"><code><span class="comment">/*
  5G NR Physical Layer Scrambling (Gold Sequence)
  As per 3GPP TS 38.211 §5.2.1
  
  Purpose: Generate pseudorandom scrambling sequences for PBCH
  Algorithm: Two 31-bit LFSRs (Gold sequence generator)
  Output: Cell-specific scrambling pattern for interference randomization
*/</span>

<span class="keyword">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;vector&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;cstdint&gt;</span>

<span class="comment">/**
 * Gold Sequence Generator Class
 * Implements two 31-bit LFSRs with specific feedback polynomials
 */</span>
<span class="keyword">class</span> <span class="type">GoldSequence</span>
{
<span class="keyword">private</span>:
    <span class="type">uint32_t</span> x1;   <span class="comment">// LFSR1 state (31 bits)</span>
    <span class="type">uint32_t</span> x2;   <span class="comment">// LFSR2 state (31 bits)</span>

<span class="keyword">public</span>:
    <span class="comment">/**
     * Constructor: Initialize both LFSRs
     * @param c_init: Initialization seed (typically N_ID_cell)
     */</span>
    <span class="function">GoldSequence</span>(<span class="type">uint32_t</span> c_init)
    {
        <span class="comment">// LFSR1: Initialize to 1 (binary: 000...001)</span>
        x1 = <span class="number">0x1</span>;
        
        <span class="comment">// LFSR2: Initialize to c_init (masked to 31 bits)</span>
        x2 = c_init &amp; <span class="number">0x7FFFFFFF</span>;
    }
    
    <span class="comment">/**
     * Generate next Gold sequence bit
     * Implements feedback polynomials and XOR combination
     * @return: Single pseudorandom bit (0 or 1)
     */</span>
    <span class="type">uint8_t</span> <span class="function">nextBit</span>()
    {
        <span class="comment">// LFSR1 feedback: x^31 + x^3 + 1</span>
        <span class="comment">// New bit = XOR of positions 3 and 0</span>
        <span class="type">uint8_t</span> x1_new = ((x1 &gt;&gt; <span class="number">3</span>) ^ (x1 &gt;&gt; <span class="number">0</span>)) &amp; <span class="number">1</span>;
        
        <span class="comment">// LFSR2 feedback: x^31 + x^3 + x^2 + x + 1</span>
        <span class="comment">// New bit = XOR of positions 3, 2, 1, and 0</span>
        <span class="type">uint8_t</span> x2_new = 
            ((x2 &gt;&gt; <span class="number">3</span>) ^ (x2 &gt;&gt; <span class="number">2</span>) ^ (x2 &gt;&gt; <span class="number">1</span>) ^ (x2 &gt;&gt; <span class="number">0</span>)) &amp; <span class="number">1</span>;
        
        <span class="comment">// Shift registers right and insert new bit at position 30</span>
        x1 = (x1 &gt;&gt; <span class="number">1</span>) | (x1_new &lt;&lt; <span class="number">30</span>);
        x2 = (x2 &gt;&gt; <span class="number">1</span>) | (x2_new &lt;&lt; <span class="number">30</span>);
        
        <span class="comment">// Gold sequence output: XOR of both LFSR outputs</span>
        <span class="keyword">return</span> (x1 ^ x2) &amp; <span class="number">1</span>;
    }
};

<span class="comment">/**
 * PBCH Physical Layer Scrambler
 * Applies cell-specific scrambling to PBCH bits
 * 
 * @param inputBits: Vector of input bits to scramble
 * @param N_ID_cell: Physical Cell ID (0-1007)
 * @param v: SSB index mod 4 (0-3)
 * @return: Vector of scrambled output bits
 */</span>
std::<span class="type">vector</span>&lt;<span class="type">uint8_t</span>&gt; <span class="function">pbchScramble</span>(
        <span class="keyword">const</span> std::<span class="type">vector</span>&lt;<span class="type">uint8_t</span>&gt;&amp; inputBits,
        <span class="type">uint32_t</span> N_ID_cell,
        <span class="type">uint32_t</span> v)
{
    <span class="comment">// Constants as per 3GPP specification</span>
    <span class="keyword">const</span> <span class="type">int</span> Nc = <span class="number">1600</span>;              <span class="comment">// Warm-up cycles</span>
    <span class="type">int</span> M_bit = inputBits.size();  <span class="comment">// Number of bits to scramble</span>
    
    <span class="comment">// Initialize Gold sequence generator with cell ID</span>
    <span class="type">GoldSequence</span> gold(N_ID_cell);
    
    <span class="comment">// Warm-up phase: Skip initial bits for proper randomization</span>
    <span class="comment">// Total skip = Nc + offset, where offset = v * M_bit</span>
    <span class="type">int</span> offset = v * M_bit;
    <span class="type">int</span> skip = Nc + offset;
    
    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; skip; i++)
        gold.<span class="function">nextBit</span>();  <span class="comment">// Advance LFSR state</span>
    
    <span class="comment">// Scrambling operation: XOR input bits with Gold sequence</span>
    std::<span class="type">vector</span>&lt;<span class="type">uint8_t</span>&gt; output(M_bit);
    
    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M_bit; i++)
    {
        <span class="type">uint8_t</span> c = gold.<span class="function">nextBit</span>();        <span class="comment">// Generate scrambling bit</span>
        output[i] = inputBits[i] ^ c;  <span class="comment">// XOR with input</span>
    }
    
    <span class="keyword">return</span> output;
}

<span class="comment">/* ================ TEST PROGRAM ================ */</span>

<span class="type">int</span> <span class="function">main</span>()
{
    std::cout &lt;&lt; <span class="string">"5G NR PBCH Physical Layer Scrambler\n"</span>;
    std::cout &lt;&lt; <span class="string">"====================================\n\n"</span>;
    
    <span class="comment">// Create example input pattern (simulating 864-bit PBCH)</span>
    std::<span class="type">vector</span>&lt;<span class="type">uint8_t</span>&gt; bits = {
        <span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,
        <span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>
    };
    
    <span class="comment">// Repeat pattern to reach 864 bits</span>
    <span class="keyword">while</span> (bits.size() &lt; <span class="number">864</span>)
        bits.insert(bits.end(), bits.begin(), bits.end());
    bits.resize(<span class="number">864</span>);
    
    <span class="comment">// Scrambling parameters</span>
    <span class="type">uint32_t</span> N_ID_cell = <span class="number">276</span>;   <span class="comment">// Example Physical Cell ID</span>
    <span class="type">uint32_t</span> v = <span class="number">3</span>;           <span class="comment">// SSB index mod 4</span>
    
    std::cout &lt;&lt; <span class="string">"Parameters:\n"</span>;
    std::cout &lt;&lt; <span class="string">"  Physical Cell ID: "</span> &lt;&lt; N_ID_cell &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="string">"  SSB index (v):    "</span> &lt;&lt; v &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="string">"  Input bits:       "</span> &lt;&lt; bits.size() &lt;&lt; std::endl;
    std::cout &lt;&lt; std::endl;
    
    <span class="comment">// Perform scrambling</span>
    <span class="keyword">auto</span> scrambled = <span class="function">pbchScramble</span>(bits, N_ID_cell, v);
    
    <span class="comment">// Display results</span>
    std::cout &lt;&lt; <span class="string">"Input (first 32 bits):     "</span>;
    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)
        std::cout &lt;&lt; <span class="type">int</span>(bits[i]);
    std::cout &lt;&lt; std::endl;
    
    std::cout &lt;&lt; <span class="string">"Scrambled (first 32 bits): "</span>;
    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)
        std::cout &lt;&lt; <span class="type">int</span>(scrambled[i]);
    std::cout &lt;&lt; std::endl &lt;&lt; std::endl;
    
    std::cout &lt;&lt; <span class="string">"✓ Scrambling completed successfully!\n"</span>;
    std::cout &lt;&lt; <span class="string">"✓ Output appears randomized due to Gold sequence\n"</span>;
    
    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre>
        </div>

        <div class="grid-layout" style="margin-top: 35px;">
            <div class="info-card">
                <h3><i class="fas fa-terminal"></i> Compilation & Execution</h3>
                <div style="background: #0d1117; padding: 20px; border-radius: 12px; margin-top: 15px;">
                    <pre style="padding: 0; color: #22c55e; font-size: 0.95rem;"><code><span class="comment"># Compile with C++11 or later</span>
g++ -std=c++11 -O2 pbch_scrambler.cpp -o scrambler

<span class="comment"># Run the scrambler</span>
./scrambler

<span class="comment"># With optimization flags for production</span>
g++ -std=c++17 -O3 -march=native pbch_scrambler.cpp -o scrambler</code></pre>
                </div>

                <h3 style="margin-top: 30px;"><i class="fas fa-display"></i> Expected Output</h3>
                <div style="background: #0d1117; padding: 20px; border-radius: 12px; margin-top: 15px; border: 2px solid var(--green-success);">
                    <pre style="padding: 0; color: #a5d6ff; font-size: 0.9rem;"><code>5G NR PBCH Physical Layer Scrambler
====================================

Parameters:
  Physical Cell ID: 276
  SSB index (v):    3
  Input bits:       864

Input (first 32 bits):     01101001101100101101001011010010
Scrambled (first 32 bits): 10110011001110101001100110011010

✓ Scrambling completed successfully!
✓ Output appears randomized due to Gold sequence</code></pre>
                </div>
            </div>

            <div class="info-card">
                <h3><i class="fas fa-rocket"></i> Algorithm Complexity</h3>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="value">O(N)</div>
                        <div class="label">Time Complexity</div>
                    </div>
                    <div class="stat-card">
                        <div class="value">O(1)</div>
                        <div class="label">Space Complexity</div>
                    </div>
                </div>

                <p style="margin-top: 20px;">
                    Where N = number of bits to scramble. The algorithm is highly efficient with constant memory usage (two 32-bit registers) and linear time proportional to the number of bits.
                </p>

                <h3 style="margin-top: 30px;"><i class="fas fa-microchip"></i> Performance Analysis</h3>
                <div style="background: rgba(20, 184, 166, 0.1); padding: 20px; border-radius: 12px; border: 2px solid var(--teal-highlight);">
                    <p style="margin: 8px 0;"><strong>Throughput:</strong> ~1-2 μs for 864 bits on modern CPUs</p>
                    <p style="margin: 8px 0;"><strong>Operations:</strong> 2 XOR + 2 shifts per bit</p>
                    <p style="margin: 8px 0;"><strong>Memory:</strong> 64 bytes (two 32-bit registers + vectors)</p>
                    <p style="margin: 8px 0;"><strong>Parallelization:</strong> Can process multiple blocks simultaneously</p>
                </div>

                <h3 style="margin-top: 30px;"><i class="fas fa-book"></i> 3GPP Standards Reference</h3>
                <div style="background: rgba(168, 85, 247, 0.1); padding: 20px; border-radius: 12px; border: 2px solid var(--purple-primary);">
                    <p style="margin: 0; color: var(--text-main);">
                        <strong>3GPP TS 38.211</strong><br>
                        Section 5.2.1: Pseudorandom sequence generation<br>
                        Section 7.3.3: Physical broadcast channel<br>
                        <a href="https://www.3gpp.org/specifications" target="_blank" style="color: var(--cyan-secondary); text-decoration: none;">
                            → Download Full Specification
                        </a>
                    </p>
                </div>

                <h3 style="margin-top: 30px;"><i class="fas fa-wrench"></i> Optimization Tips</h3>
                <div style="background: rgba(245, 158, 11, 0.1); padding: 20px; border-radius: 12px; border-left: 4px solid var(--orange-warning);">
                    <p style="margin: 8px 0;">• Use SIMD instructions (AVX2/AVX512) for vectorization</p>
                    <p style="margin: 8px 0;">• Pre-compute Gold sequences for common cell IDs</p>
                    <p style="margin: 8px 0;">• Implement in hardware (FPGA/ASIC) for real-time processing</p>
                    <p style="margin: 8px 0;">• Consider lookup tables for small scrambling blocks</p>
                </div>
            </div>
        </div>
    </div>
</div>

<footer>
    <p style="font-size: 1.2rem; font-weight: 700; margin-bottom: 15px;">
        <i class="fas fa-shield-alt"></i> 5G NR Physical Layer Scrambling Deep Dive
    </p>
    <p style="font-size: 0.9rem;">
        3GPP TS 38.211 §5.2.1 • Gold Sequence • PBCH Security
    </p>
    <p style="font-size: 0.85rem; margin-top: 10px; color: var(--text-dim);">
        Pseudorandom Generation • Interference Randomization • Cell Differentiation
    </p>
</footer>

<script>
    // Tab Switching
    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
            btn.classList.add('active');
            document.getElementById(btn.dataset.target).classList.add('active');
        });
    });

    // LFSR State
    let x1State = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    let x2State = [1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0]; // Example init

    // Generate LFSR Displays
    function generateLFSRs() {
        const lfsr1 = document.getElementById('lfsr1');
        const lfsr2 = document.getElementById('lfsr2');
        
        // LFSR1
        for (let i = 30; i >= 0; i--) {
            const bit = document.createElement('div');
            bit.className = 'lfsr-bit' + (x1State[i] === 0 ? ' zero' : '');
            bit.textContent = x1State[i];
            if (i === 3 || i === 0) bit.classList.add('tap-indicator');
            lfsr1.appendChild(bit);
        }
        
        // LFSR2
        for (let i = 30; i >= 0; i--) {
            const bit = document.createElement('div');
            bit.className = 'lfsr-bit' + (x2State[i] === 0 ? ' zero' : '');
            bit.textContent = x2State[i];
            if (i === 3 || i === 2 || i === 1 || i === 0) bit.classList.add('tap-indicator');
            lfsr2.appendChild(bit);
        }
    }

    // Step LFSR
    function stepLFSR() {
        // LFSR1 feedback
        const x1New = (x1State[3] + x1State[0]) % 2;
        x1State.unshift(x1New);
        x1State.pop();
        
        // LFSR2 feedback
        const x2New = (x2State[3] + x2State[2] + x2State[1] + x2State[0]) % 2;
        x2State.unshift(x2New);
        x2State.pop();
        
        // Update display
        document.getElementById('lfsr1').innerHTML = '';
        document.getElementById('lfsr2').innerHTML = '';
        generateLFSRs();
        
        // Update XOR demo
        document.getElementById('x1-out').textContent = x1State[0];
        document.getElementById('x2-out').textContent = x2State[0];
        document.getElementById('gold-out').textContent = (x1State[0] + x2State[0]) % 2;
    }

    // Run LFSR
    function runLFSR() {
        let count = 0;
        const interval = setInterval(() => {
            stepLFSR();
            count++;
            if (count >= 20) clearInterval(interval);
        }, 100);
    }

    // Reset LFSR
    function resetLFSR() {
        x1State = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        x2State = [1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0];
        
        document.getElementById('lfsr1').innerHTML = '';
        document.getElementById('lfsr2').innerHTML = '';
        generateLFSRs();
        
        document.getElementById('x1-out').textContent = x1State[0];
        document.getElementById('x2-out').textContent = x2State[0];
        document.getElementById('gold-out').textContent = (x1State[0] + x2State[0]) % 2;
    }

    // Generate Sequences for Demo
    function generateSequences() {
        const inputSeq = document.getElementById('input-sequence');
        const goldSeq = document.getElementById('gold-sequence');
        const outputSeq = document.getElementById('output-sequence');
        
        inputSeq.innerHTML = '';
        goldSeq.innerHTML = '';
        outputSeq.innerHTML = '';
        
        for (let i = 0; i < 32; i++) {
            const inputBit = Math.random() > 0.5 ? 1 : 0;
            const goldBit = Math.random() > 0.5 ? 1 : 0;
            const outputBit = inputBit ^ goldBit;
            
            const inBitEl = document.createElement('div');
            inBitEl.className = 'seq-bit' + (inputBit === 0 ? ' zero' : '');
            inBitEl.textContent = inputBit;
            inputSeq.appendChild(inBitEl);
            
            const goldBitEl = document.createElement('div');
            goldBitEl.className = 'seq-bit' + (goldBit === 0 ? ' zero' : '');
            goldBitEl.textContent = goldBit;
            goldSeq.appendChild(goldBitEl);
            
            const outBitEl = document.createElement('div');
            outBitEl.className = 'seq-bit' + (outputBit === 0 ? ' zero' : '');
            outBitEl.textContent = outputBit;
            outputSeq.appendChild(outBitEl);
        }
    }

    // Copy Code
    function copyCode() {
        const codeBlock = document.getElementById('code-block');
        const text = codeBlock.innerText;
        
        navigator.clipboard.writeText(text).then(() => {
            const btn = document.querySelector('.copy-btn');
            const originalText = btn.innerHTML;
            btn.innerHTML = '<i class="fas fa-check"></i> Copied!';
            btn.style.background = 'var(--green-success)';
            
            setTimeout(() => {
                btn.innerHTML = originalText;
                btn.style.background = 'var(--purple-primary)';
            }, 2000);
        });
    }

    // Initialize on load
    window.addEventListener('load', () => {
        generateLFSRs();
        generateSequences();
        document.getElementById('x1-out').textContent = x1State[0];
        document.getElementById('x2-out').textContent = x2State[0];
        document.getElementById('gold-out').textContent = (x1State[0] + x2State[0]) % 2;
    });
</script>

</body>
</html>