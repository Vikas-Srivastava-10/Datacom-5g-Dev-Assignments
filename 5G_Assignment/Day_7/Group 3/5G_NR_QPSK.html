<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>5G NR QPSK Modulation - Advanced Guide</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            /* Modern Color Palette */
            --bg-body: #0a0e27;
            --bg-card: #151b3d;
            --primary-purple: #a855f7;
            --primary-cyan: #06b6d4;
            --primary-magenta: #ec4899;
            --primary-teal: #14b8a6;
            --accent-orange: #f59e0b;
            --accent-green: #22c55e;
            --accent-blue: #3b82f6;
            --accent-red: #ef4444;
            --text-main: #f8fafc;
            --text-dim: #94a3b8;
            --border: #1e293b;
            --code-bg: #1e1e2e;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f4d 100%);
            color: var(--text-main);
            font-family: 'Inter', sans-serif;
            line-height: 1.8;
            padding-bottom: 50px;
            min-height: 100vh;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.15) 0%, rgba(59, 130, 246, 0.15) 100%);
            padding: 50px 40px;
            border-bottom: 3px solid var(--accent-blue);
            text-align: center;
            backdrop-filter: blur(15px);
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(59, 130, 246, 0.15) 0%, transparent 70%);
            animation: rotate 25s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .logo { 
            font-weight: 800; 
            font-size: 2.5rem; 
            background: linear-gradient(135deg, var(--accent-blue) 0%, var(--primary-cyan) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -2px;
            position: relative;
            z-index: 1;
            margin-bottom: 10px;
        }
        
        .logo i {
            color: var(--accent-blue);
            margin-right: 15px;
        }

        .header-desc { 
            color: var(--text-dim); 
            font-size: 1.1rem; 
            margin-top: 15px;
            position: relative;
            z-index: 1;
            font-weight: 300;
        }

        .container { 
            max-width: 1400px; 
            margin: 0 auto; 
            padding: 40px 25px; 
        }

        /* Section Styles */
        .section {
            margin-bottom: 60px;
            animation: fadeInUp 0.8s ease-out;
        }

        @keyframes fadeInUp { 
            from { opacity: 0; transform: translateY(40px); } 
            to { opacity: 1; transform: translateY(0); } 
        }

        .section-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--border);
        }

        .section-header i {
            font-size: 2rem;
            color: var(--accent-blue);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }

        .section-header h2 {
            font-size: 2rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-blue) 0%, var(--primary-cyan) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Info Cards */
        .info-card {
            background: linear-gradient(135deg, var(--bg-card) 0%, rgba(21, 27, 61, 0.9) 100%);
            padding: 40px;
            border-radius: 25px;
            border: 1px solid var(--border);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            margin-bottom: 30px;
        }

        .info-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 20px 60px rgba(59, 130, 246, 0.3);
            border-color: var(--accent-blue);
        }

        .info-card h3 {
            color: var(--accent-blue);
            font-size: 1.5rem;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .info-card p {
            color: var(--text-dim);
            font-size: 1.05rem;
            line-height: 2;
            margin-bottom: 15px;
        }

        /* Grid Layout */
        .grid-2 {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 30px;
        }

        .grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 25px;
        }

        @media (max-width: 1024px) {
            .grid-2, .grid-3 { grid-template-columns: 1fr; }
        }

        /* Architecture Diagram */
        .architecture-container {
            background: rgba(0, 0, 0, 0.4);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid var(--accent-blue);
            position: relative;
            overflow: hidden;
        }

        .architecture-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.05) 0%, transparent 100%);
            pointer-events: none;
        }

        .arch-layer {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.1) 0%, rgba(59, 130, 246, 0.1) 100%);
            padding: 25px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 20px;
            text-align: center;
            position: relative;
            transition: all 0.3s ease;
        }

        .arch-layer:hover {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.2) 0%, rgba(59, 130, 246, 0.2) 100%);
            border-color: var(--accent-blue);
            transform: scale(1.02);
        }

        .arch-layer h4 {
            color: var(--primary-cyan);
            font-size: 1.3rem;
            margin-bottom: 10px;
        }

        .arch-layer p {
            color: var(--text-dim);
            font-size: 0.95rem;
        }

        .arch-arrow {
            text-align: center;
            font-size: 2rem;
            color: var(--accent-blue);
            margin: 15px 0;
            animation: bounce 2s ease-in-out infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* Constellation Diagram */
        .constellation-container {
            background: rgba(0, 0, 0, 0.6);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid var(--accent-blue);
            margin: 30px 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #constellationCanvas {
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
        }

        /* Symbol Points */
        .symbol-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin: 30px 0;
        }

        .symbol-card {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(6, 182, 212, 0.1) 100%);
            padding: 25px;
            border-radius: 15px;
            border: 2px solid rgba(59, 130, 246, 0.3);
            text-align: center;
            transition: all 0.3s ease;
        }

        .symbol-card:hover {
            border-color: var(--accent-blue);
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(59, 130, 246, 0.3);
        }

        .symbol-card h4 {
            color: var(--accent-blue);
            font-size: 1.2rem;
            margin-bottom: 15px;
        }

        .symbol-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.5rem;
            color: var(--text-main);
            margin: 10px 0;
        }

        .symbol-bits {
            background: rgba(0, 0, 0, 0.4);
            padding: 10px;
            border-radius: 8px;
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent-green);
            font-weight: 600;
        }

        /* Code Block */
        .code-container {
            background: var(--code-bg);
            border-radius: 20px;
            border: 2px solid var(--primary-purple);
            overflow: hidden;
            margin: 30px 0;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
        }

        .code-header {
            background: linear-gradient(135deg, var(--primary-purple) 0%, #9333ea 100%);
            padding: 15px 25px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .code-header h4 {
            color: white;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .code-lang {
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .code-content {
            padding: 30px;
            overflow-x: auto;
        }

        .code-content pre {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.8;
            color: #e0e0e0;
        }

        .code-content code {
            color: #e0e0e0;
        }

        /* Syntax Highlighting */
        .keyword { color: #c678dd; font-weight: 600; }
        .type { color: #61afef; }
        .function { color: #61afef; }
        .string { color: #98c379; }
        .number { color: #d19a66; }
        .comment { color: #5c6370; font-style: italic; }
        .operator { color: #56b6c2; }
        .preprocessor { color: #e06c75; }

        /* Stats Box */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .stat-box {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(6, 182, 212, 0.1) 100%);
            padding: 25px;
            border-radius: 15px;
            border: 2px solid var(--accent-blue);
            text-align: center;
            transition: all 0.3s ease;
        }

        .stat-box:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(59, 130, 246, 0.3);
        }

        .stat-box i {
            font-size: 2.5rem;
            color: var(--accent-blue);
            margin-bottom: 15px;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 800;
            color: var(--text-main);
            margin-bottom: 10px;
        }

        .stat-label {
            color: var(--text-dim);
            font-size: 0.95rem;
        }

        /* Feature Cards */
        .feature-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin: 30px 0;
        }

        .feature-card {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.05) 0%, rgba(168, 85, 247, 0.05) 100%);
            padding: 30px;
            border-radius: 20px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .feature-card:hover {
            border-color: var(--accent-blue);
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(168, 85, 247, 0.1) 100%);
            transform: translateY(-5px);
        }

        .feature-card i {
            font-size: 2.5rem;
            color: var(--accent-blue);
            margin-bottom: 15px;
        }

        .feature-card h4 {
            color: var(--text-main);
            font-size: 1.3rem;
            margin-bottom: 15px;
        }

        .feature-card p {
            color: var(--text-dim);
            font-size: 0.95rem;
            line-height: 1.8;
        }

        /* Comparison Table */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            overflow: hidden;
        }

        table thead {
            background: linear-gradient(135deg, var(--accent-blue) 0%, var(--primary-cyan) 100%);
        }

        table th {
            padding: 15px;
            color: white;
            font-weight: 700;
            text-align: left;
        }

        table td {
            padding: 15px;
            color: var(--text-dim);
            border-bottom: 1px solid var(--border);
        }

        table tr:hover {
            background: rgba(59, 130, 246, 0.1);
        }

        /* Highlight Box */
        .highlight-box {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.1) 0%, rgba(59, 130, 246, 0.1) 100%);
            padding: 25px;
            border-radius: 15px;
            border-left: 5px solid var(--accent-green);
            margin: 25px 0;
        }

        .highlight-box h4 {
            color: var(--accent-green);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .highlight-box p {
            color: var(--text-dim);
            line-height: 2;
        }

        /* Warning Box */
        .warning-box {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.1) 0%, rgba(239, 68, 68, 0.1) 100%);
            padding: 25px;
            border-radius: 15px;
            border-left: 5px solid var(--accent-orange);
            margin: 25px 0;
        }

        .warning-box h4 {
            color: var(--accent-orange);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .warning-box p {
            color: var(--text-dim);
            line-height: 2;
        }

        /* Interactive Controls */
        .interactive-demo {
            background: rgba(0, 0, 0, 0.4);
            padding: 30px;
            border-radius: 20px;
            border: 2px solid var(--accent-blue);
            margin: 30px 0;
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            color: var(--text-main);
            font-weight: 600;
            display: block;
            margin-bottom: 10px;
        }

        .control-group input[type="text"] {
            width: 100%;
            padding: 12px;
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: 10px;
            color: var(--text-main);
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .control-group input[type="text"]:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.3);
        }

        button {
            background: linear-gradient(135deg, var(--accent-blue) 0%, var(--primary-cyan) 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 10px;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(59, 130, 246, 0.4);
        }

        .output-display {
            background: rgba(0, 0, 0, 0.5);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent-green);
            min-height: 100px;
        }

        /* Footer */
        footer {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.6) 0%, rgba(21, 27, 61, 0.6) 100%);
            padding: 30px;
            text-align: center;
            border-top: 2px solid var(--accent-blue);
            margin-top: 60px;
        }

        footer p {
            color: var(--text-dim);
            font-size: 0.95rem;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-body);
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, var(--accent-blue) 0%, var(--primary-cyan) 100%);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, var(--primary-cyan) 0%, var(--accent-blue) 100%);
        }

        /* Waveform Animation */
        .waveform-container {
            background: rgba(0, 0, 0, 0.6);
            padding: 30px;
            border-radius: 20px;
            border: 2px solid var(--primary-cyan);
            margin: 30px 0;
            text-align: center;
        }

        #waveformCanvas {
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
        }

        /* Phase Diagram */
        .phase-points {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .phase-point {
            background: rgba(0, 0, 0, 0.4);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid var(--accent-blue);
            text-align: center;
        }

        .phase-point h5 {
            color: var(--accent-blue);
            margin-bottom: 10px;
        }

        .phase-point .angle {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.2rem;
            color: var(--text-main);
            margin: 5px 0;
        }

        .phase-point .coordinates {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            color: var(--text-dim);
        }
    </style>
</head>
<body>

<header>
    <h1 class="logo"><i class="fas fa-wave-square"></i>QPSK Modulation in 5G NR</h1>
    <p class="header-desc">Quadrature Phase Shift Keying - Foundation of Digital Modulation</p>
</header>

<div class="container">
    
    <!-- Introduction Section -->
    <section class="section">
        <div class="section-header">
            <i class="fas fa-info-circle"></i>
            <h2>What is QPSK Modulation?</h2>
        </div>
        
        <div class="info-card">
            <h3><i class="fas fa-signal"></i> Introduction to QPSK</h3>
            <p>
                Quadrature Phase Shift Keying (QPSK) is a fundamental digital modulation technique used extensively in 5G New Radio (NR) physical layer communications. QPSK represents a second-order modulation scheme that transmits two bits of information per symbol by modulating the carrier signal's phase across four distinct states separated by 90 degrees (π/2 radians). This modulation technique achieves a balance between spectral efficiency and robustness, making it particularly valuable for scenarios requiring reliable communications in challenging channel conditions such as cell edge users, high mobility environments, or initial network access procedures.
            </p>
            <p>
                In 5G NR systems, QPSK serves as the most robust modulation scheme in the adaptive modulation and coding (AMC) framework. The four constellation points in QPSK are typically positioned at phases of 45°, 135°, 225°, and 315° (or π/4, 3π/4, 5π/4, 7π/4 radians), representing the binary sequences 00, 01, 10, and 11 respectively. This configuration provides maximum Euclidean distance between constellation points, enhancing noise immunity and reducing bit error rates (BER) compared to higher-order modulation schemes. The modulation process involves mapping pairs of information bits to complex symbols with equal amplitude but different phases, enabling the transmission of 2 bits per resource element, which translates to a spectral efficiency of 2 bits/Hz under ideal conditions.
            </p>
            <p>
                The importance of QPSK in 5G NR extends beyond its role as a basic modulation scheme. It is crucial for control channel transmissions (PDCCH/PUCCH), synchronization signals (PSS/SSS), broadcast channels (PBCH), and initial random access procedures (PRACH). QPSK's robustness makes it ideal for maintaining link reliability when signal-to-noise ratio (SNR) is low, typically below 10 dB. Modern 5G implementations combine QPSK with advanced techniques such as low-density parity-check (LDPC) coding, HARQ retransmissions, and beamforming to achieve ultra-reliable low-latency communications (URLLC). The scheme's simplicity also reduces computational complexity in both transmitter and receiver, making it energy-efficient for battery-powered IoT devices while maintaining sufficient data rates for control signaling and basic data services.
            </p>
        </div>
    </section>

    <!-- Architecture Section -->
    <section class="section">
        <div class="section-header">
            <i class="fas fa-project-diagram"></i>
            <h2>QPSK Modulation Architecture</h2>
        </div>

        <div class="architecture-container">
            <div class="arch-layer">
                <h4><i class="fas fa-database"></i> Layer 1: Binary Data Input</h4>
                <p>Input bit stream from channel encoder (LDPC/Polar) ready for modulation mapping</p>
            </div>
            <div class="arch-arrow"><i class="fas fa-arrow-down"></i></div>
            
            <div class="arch-layer">
                <h4><i class="fas fa-th"></i> Layer 2: Serial-to-Parallel Conversion</h4>
                <p>Group consecutive bits into pairs (dibits) for simultaneous transmission on I and Q channels</p>
            </div>
            <div class="arch-arrow"><i class="fas fa-arrow-down"></i></div>
            
            <div class="arch-layer">
                <h4><i class="fas fa-map"></i> Layer 3: Symbol Mapping</h4>
                <p>Map each 2-bit pattern to corresponding constellation point (±1/√2, ±j/√2)</p>
            </div>
            <div class="arch-arrow"><i class="fas fa-arrow-down"></i></div>
            
            <div class="arch-layer">
                <h4><i class="fas fa-wave-square"></i> Layer 4: Complex Symbol Generation</h4>
                <p>Create complex-valued symbols I(t) + jQ(t) representing in-phase and quadrature components</p>
            </div>
            <div class="arch-arrow"><i class="fas fa-arrow-down"></i></div>
            
            <div class="arch-layer">
                <h4><i class="fas fa-broadcast-tower"></i> Layer 5: Carrier Modulation & Transmission</h4>
                <p>Modulate RF carrier with I/Q components and transmit via OFDM subcarriers in 5G NR</p>
            </div>
        </div>
    </section>

    <!-- Constellation Diagram -->
    <section class="section">
        <div class="section-header">
            <i class="fas fa-braille"></i>
            <h2>QPSK Constellation Diagram</h2>
        </div>

        <div class="constellation-container">
            <canvas id="constellationCanvas" width="600" height="600"></canvas>
        </div>

        <div class="symbol-grid">
            <div class="symbol-card">
                <h4>Symbol 00</h4>
                <div class="symbol-value">1/√2 + j(1/√2)</div>
                <div class="symbol-bits">Bits: 00 | Phase: 45°</div>
                <p style="margin-top: 10px; color: var(--text-dim); font-size: 0.9rem;">First Quadrant</p>
            </div>

            <div class="symbol-card">
                <h4>Symbol 01</h4>
                <div class="symbol-value">-1/√2 + j(1/√2)</div>
                <div class="symbol-bits">Bits: 01 | Phase: 135°</div>
                <p style="margin-top: 10px; color: var(--text-dim); font-size: 0.9rem;">Second Quadrant</p>
            </div>

            <div class="symbol-card">
                <h4>Symbol 10</h4>
                <div class="symbol-value">1/√2 - j(1/√2)</div>
                <div class="symbol-bits">Bits: 10 | Phase: 315°</div>
                <p style="margin-top: 10px; color: var(--text-dim); font-size: 0.9rem;">Fourth Quadrant</p>
            </div>

            <div class="symbol-card">
                <h4>Symbol 11</h4>
                <div class="symbol-value">-1/√2 - j(1/√2)</div>
                <div class="symbol-bits">Bits: 11 | Phase: 225°</div>
                <p style="margin-top: 10px; color: var(--text-dim); font-size: 0.9rem;">Third Quadrant</p>
            </div>
        </div>

        <div class="phase-points">
            <div class="phase-point">
                <h5><i class="fas fa-angle-double-right"></i> Phase 0° (45°)</h5>
                <div class="angle">π/4 radians</div>
                <div class="coordinates">(0.707, 0.707)</div>
            </div>
            <div class="phase-point">
                <h5><i class="fas fa-angle-double-up"></i> Phase 90° (135°)</h5>
                <div class="angle">3π/4 radians</div>
                <div class="coordinates">(-0.707, 0.707)</div>
            </div>
            <div class="phase-point">
                <h5><i class="fas fa-angle-double-down"></i> Phase 270° (315°)</h5>
                <div class="angle">7π/4 radians</div>
                <div class="coordinates">(0.707, -0.707)</div>
            </div>
            <div class="phase-point">
                <h5><i class="fas fa-angle-double-left"></i> Phase 180° (225°)</h5>
                <div class="angle">5π/4 radians</div>
                <div class="coordinates">(-0.707, -0.707)</div>
            </div>
        </div>
    </section>

    <!-- Stats Section -->
    <section class="section">
        <div class="section-header">
            <i class="fas fa-chart-bar"></i>
            <h2>QPSK Performance Metrics</h2>
        </div>

        <div class="stats-grid">
            <div class="stat-box">
                <i class="fas fa-layer-group"></i>
                <div class="stat-value">2</div>
                <div class="stat-label">Bits per Symbol</div>
            </div>
            <div class="stat-box">
                <i class="fas fa-th-large"></i>
                <div class="stat-value">4</div>
                <div class="stat-label">Constellation Points</div>
            </div>
            <div class="stat-box">
                <i class="fas fa-angle-double-right"></i>
                <div class="stat-value">90°</div>
                <div class="stat-label">Phase Separation</div>
            </div>
            <div class="stat-box">
                <i class="fas fa-tachometer-alt"></i>
                <div class="stat-value">2</div>
                <div class="stat-label">Spectral Efficiency (bits/Hz)</div>
            </div>
        </div>
    </section>

    <!-- Key Features -->
    <section class="section">
        <div class="section-header">
            <i class="fas fa-star"></i>
            <h2>Key Features of QPSK</h2>
        </div>

        <div class="feature-cards">
            <div class="feature-card">
                <i class="fas fa-shield-alt"></i>
                <h4>High Robustness</h4>
                <p>Maximum distance between constellation points provides excellent noise immunity, ideal for low SNR conditions and cell edge users.</p>
            </div>

            <div class="feature-card">
                <i class="fas fa-balance-scale"></i>
                <h4>Constant Envelope</h4>
                <p>All symbols have equal amplitude, enabling efficient power amplifier operation and reducing peak-to-average power ratio (PAPR).</p>
            </div>

            <div class="feature-card">
                <i class="fas fa-microchip"></i>
                <h4>Low Complexity</h4>
                <p>Simple implementation in both hardware and software with minimal computational requirements for modulation and demodulation.</p>
            </div>

            <div class="feature-card">
                <i class="fas fa-signal"></i>
                <h4>Spectral Efficiency</h4>
                <p>Achieves 2 bits/Hz theoretical spectral efficiency, doubling the capacity compared to BPSK while maintaining good BER performance.</p>
            </div>

            <div class="feature-card">
                <i class="fas fa-network-wired"></i>
                <h4>Gray Coding Compatible</h4>
                <p>Adjacent symbols differ by only one bit, minimizing bit errors when symbol errors occur due to noise or interference.</p>
            </div>

            <div class="feature-card">
                <i class="fas fa-bolt"></i>
                <h4>Energy Efficient</h4>
                <p>Optimal for battery-powered IoT devices and UE in power-saving mode, requiring lower transmit power for given BER targets.</p>
            </div>
        </div>
    </section>

    <!-- Waveform Visualization -->
    <section class="section">
        <div class="section-header">
            <i class="fas fa-water"></i>
            <h2>QPSK Waveform Visualization</h2>
        </div>

        <div class="waveform-container">
            <h3 style="color: var(--primary-cyan); margin-bottom: 20px;">
                <i class="fas fa-chart-line"></i> I/Q Component Waveforms
            </h3>
            <canvas id="waveformCanvas" width="900" height="400"></canvas>
        </div>
    </section>

    <!-- Interactive Modulator -->
    <section class="section">
        <div class="section-header">
            <i class="fas fa-sliders-h"></i>
            <h2>Interactive QPSK Modulator</h2>
        </div>

        <div class="interactive-demo">
            <div class="control-panel">
                <h3 style="color: var(--accent-blue); margin-bottom: 20px;">
                    <i class="fas fa-keyboard"></i> Enter Binary Data
                </h3>
                <div class="control-group">
                    <label for="binaryInput">Binary Input (e.g., 11001001):</label>
                    <input type="text" id="binaryInput" placeholder="Enter binary digits (0 and 1 only)" value="11001001">
                </div>
                <button onclick="modulateQPSK()">
                    <i class="fas fa-play-circle"></i> Modulate
                </button>
            </div>
            <div class="output-display" id="modulationOutput">
                Enter binary data and click Modulate to see QPSK symbols...
            </div>
        </div>
    </section>

    <!-- C++ Implementation -->
    <section class="section">
        <div class="section-header">
            <i class="fas fa-code"></i>
            <h2>C++ Implementation</h2>
        </div>

        <div class="code-container">
            <div class="code-header">
                <h4><i class="fas fa-file-code"></i> QPSKModulator.cpp - Complete Implementation</h4>
                <span class="code-lang">C++17</span>
            </div>
            <div class="code-content">
<pre><code><span class="preprocessor">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;vector&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;complex&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;cmath&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;bitset&gt;</span>
<span class="preprocessor">#include</span> <span class="string">&lt;iomanip&gt;</span>

<span class="keyword">using namespace</span> std;

<span class="comment">/**
 * @class QPSKModulator
 * @brief QPSK Modulation and Demodulation for 5G NR Physical Layer
 * 
 * Implements Quadrature Phase Shift Keying modulation/demodulation
 * according to 3GPP TS 38.211 specifications for 5G NR.
 */</span>
<span class="keyword">class</span> <span class="type">QPSKModulator</span> {
<span class="keyword">private</span>:
    <span class="comment">// QPSK constellation points (normalized to unit power)</span>
    <span class="keyword">const</span> <span class="type">double</span> NORM_FACTOR = <span class="number">1.0</span> / <span class="function">sqrt</span>(<span class="number">2.0</span>);
    
    <span class="comment">/**
     * @brief QPSK symbol mapping table
     * Maps 2-bit patterns to complex constellation points
     * Using Gray coding: adjacent symbols differ by 1 bit
     */</span>
    <span class="keyword">struct</span> <span class="type">ConstellationPoint</span> {
        <span class="type">string</span> bits;
        <span class="type">complex</span>&lt;<span class="type">double</span>&gt; symbol;
        <span class="type">double</span> phase;  <span class="comment">// in radians</span>
    };
    
    <span class="type">vector</span>&lt;<span class="type">ConstellationPoint</span>&gt; constellation;
    
    <span class="comment">/**
     * @brief Initialize QPSK constellation with Gray coding
     * 
     * Gray coding ensures adjacent constellation points differ by 1 bit
     * Mapping (3GPP TS 38.211):
     * 00 → (1+j)/√2   [Phase: π/4]
     * 01 → (-1+j)/√2  [Phase: 3π/4]
     * 11 → (-1-j)/√2  [Phase: 5π/4]
     * 10 → (1-j)/√2   [Phase: 7π/4]
     */</span>
    <span class="keyword">void</span> <span class="function">initializeConstellation</span>() {
        constellation = {
            {<span class="string">"00"</span>, <span class="function">complex</span>&lt;<span class="type">double</span>&gt;(NORM_FACTOR, NORM_FACTOR),   M_PI/<span class="number">4</span>},      <span class="comment">// 45°</span>
            {<span class="string">"01"</span>, <span class="function">complex</span>&lt;<span class="type">double</span>&gt;(-NORM_FACTOR, NORM_FACTOR),  <span class="number">3</span>*M_PI/<span class="number">4</span>},    <span class="comment">// 135°</span>
            {<span class="string">"11"</span>, <span class="function">complex</span>&lt;<span class="type">double</span>&gt;(-NORM_FACTOR, -NORM_FACTOR), <span class="number">5</span>*M_PI/<span class="number">4</span>},    <span class="comment">// 225°</span>
            {<span class="string">"10"</span>, <span class="function">complex</span>&lt;<span class="type">double</span>&gt;(NORM_FACTOR, -NORM_FACTOR),  <span class="number">7</span>*M_PI/<span class="number">4</span>}     <span class="comment">// 315°</span>
        };
    }

<span class="keyword">public</span>:
    <span class="comment">/**
     * @brief Constructor - Initialize constellation
     */</span>
    <span class="function">QPSKModulator</span>() {
        <span class="function">initializeConstellation</span>();
    }
    
    <span class="comment">/**
     * @brief Modulate binary data to QPSK symbols
     * @param bits Binary input string (e.g., "11001001")
     * @return Vector of complex QPSK symbols
     */</span>
    <span class="type">vector</span>&lt;<span class="type">complex</span>&lt;<span class="type">double</span>&gt;&gt; <span class="function">modulate</span>(<span class="keyword">const</span> <span class="type">string</span>&amp; bits) {
        <span class="type">vector</span>&lt;<span class="type">complex</span>&lt;<span class="type">double</span>&gt;&gt; symbols;
        
        <span class="comment">// Ensure even number of bits (pad with 0 if needed)</span>
        <span class="type">string</span> paddedBits = bits;
        <span class="keyword">if</span> (paddedBits.<span class="function">length</span>() % <span class="number">2</span> != <span class="number">0</span>) {
            paddedBits += <span class="string">"0"</span>;
            cout &lt;&lt; <span class="string">"Warning: Odd number of bits, padded with 0
"</span>;
        }
        
        <span class="comment">// Process bits in pairs (dibits)</span>
        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; paddedBits.<span class="function">length</span>(); i += <span class="number">2</span>) {
            <span class="type">string</span> dibit = paddedBits.<span class="function">substr</span>(i, <span class="number">2</span>);
            
            <span class="comment">// Find matching constellation point</span>
            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; point : constellation) {
                <span class="keyword">if</span> (point.bits == dibit) {
                    symbols.<span class="function">push_back</span>(point.symbol);
                    <span class="keyword">break</span>;
                }
            }
        }
        
        <span class="keyword">return</span> symbols;
    }
    
    <span class="comment">/**
     * @brief Demodulate QPSK symbols to binary data
     * @param symbols Vector of received QPSK symbols
     * @return Demodulated binary string
     */</span>
    <span class="type">string</span> <span class="function">demodulate</span>(<span class="keyword">const</span> <span class="type">vector</span>&lt;<span class="type">complex</span>&lt;<span class="type">double</span>&gt;&gt;&amp; symbols) {
        <span class="type">string</span> bits = <span class="string">""</span>;
        
        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; rxSymbol : symbols) {
            <span class="comment">// Find nearest constellation point (ML decision)</span>
            <span class="type">double</span> minDistance = <span class="function">numeric_limits</span>&lt;<span class="type">double</span>&gt;::<span class="function">max</span>();
            <span class="type">string</span> decidedBits;
            
            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; point : constellation) {
                <span class="type">double</span> distance = <span class="function">abs</span>(rxSymbol - point.symbol);
                <span class="keyword">if</span> (distance &lt; minDistance) {
                    minDistance = distance;
                    decidedBits = point.bits;
                }
            }
            
            bits += decidedBits;
        }
        
        <span class="keyword">return</span> bits;
    }
    
    <span class="comment">/**
     * @brief Calculate symbol error rate with AWGN
     * @param symbols Transmitted symbols
     * @param noisePower Noise power (N0)
     * @param numTrials Number of Monte Carlo trials
     * @return Symbol Error Rate
     */</span>
    <span class="type">double</span> <span class="function">calculateSER</span>(
        <span class="keyword">const</span> <span class="type">vector</span>&lt;<span class="type">complex</span>&lt;<span class="type">double</span>&gt;&gt;&amp; symbols,
        <span class="type">double</span> noisePower,
        <span class="type">int</span> numTrials = <span class="number">10000</span>
    ) {
        <span class="type">int</span> symbolErrors = <span class="number">0</span>;
        <span class="type">int</span> totalSymbols = <span class="number">0</span>;
        
        <span class="keyword">for</span> (<span class="type">int</span> trial = <span class="number">0</span>; trial &lt; numTrials; trial++) {
            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; txSymbol : symbols) {
                <span class="comment">// Add AWGN noise</span>
                <span class="type">complex</span>&lt;<span class="type">double</span>&gt; noise(
                    <span class="function">gaussianRandom</span>(<span class="number">0</span>, noisePower),
                    <span class="function">gaussianRandom</span>(<span class="number">0</span>, noisePower)
                );
                <span class="type">complex</span>&lt;<span class="type">double</span>&gt; rxSymbol = txSymbol + noise;
                
                <span class="comment">// Demodulate and check for error</span>
                <span class="type">vector</span>&lt;<span class="type">complex</span>&lt;<span class="type">double</span>&gt;&gt; rxVec = {rxSymbol};
                <span class="type">string</span> rxBits = <span class="function">demodulate</span>(rxVec);
                
                <span class="comment">// Find original bits</span>
                <span class="type">string</span> txBits;
                <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; point : constellation) {
                    <span class="keyword">if</span> (<span class="function">abs</span>(txSymbol - point.symbol) &lt; <span class="number">0.01</span>) {
                        txBits = point.bits;
                        <span class="keyword">break</span>;
                    }
                }
                
                <span class="keyword">if</span> (rxBits != txBits) {
                    symbolErrors++;
                }
                totalSymbols++;
            }
        }
        
        <span class="keyword">return</span> (<span class="type">double</span>)symbolErrors / totalSymbols;
    }
    
    <span class="comment">/**
     * @brief Calculate theoretical BER for QPSK in AWGN
     * @param EbN0_dB Energy per bit to noise ratio (dB)
     * @return Theoretical Bit Error Rate
     */</span>
    <span class="type">double</span> <span class="function">theoreticalBER</span>(<span class="type">double</span> EbN0_dB) {
        <span class="type">double</span> EbN0 = <span class="function">pow</span>(<span class="number">10.0</span>, EbN0_dB / <span class="number">10.0</span>);
        <span class="comment">// BER = Q(sqrt(2*Eb/N0)) for QPSK with Gray coding</span>
        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="function">erfc</span>(<span class="function">sqrt</span>(EbN0));
    }
    
    <span class="comment">/**
     * @brief Display constellation diagram
     */</span>
    <span class="keyword">void</span> <span class="function">displayConstellation</span>() {
        cout &lt;&lt; <span class="string">"
========================================
"</span>;
        cout &lt;&lt; <span class="string">"  QPSK Constellation Diagram
"</span>;
        cout &lt;&lt; <span class="string">"========================================
"</span>;
        cout &lt;&lt; <span class="function">fixed</span> &lt;&lt; <span class="function">setprecision</span>(<span class="number">4</span>);
        
        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; point : constellation) {
            cout &lt;&lt; <span class="string">"Bits: "</span> &lt;&lt; point.bits 
                 &lt;&lt; <span class="string">" → Symbol: ("</span> &lt;&lt; point.symbol.<span class="function">real</span>() 
                 &lt;&lt; <span class="string">", "</span> &lt;&lt; point.symbol.<span class="function">imag</span>() &lt;&lt; <span class="string">"j)"</span>
                 &lt;&lt; <span class="string">" | Phase: "</span> &lt;&lt; (point.phase * <span class="number">180.0</span> / M_PI) &lt;&lt; <span class="string">"°
"</span>;
        }
        cout &lt;&lt; <span class="string">"========================================

"</span>;
    }
    
    <span class="comment">/**
     * @brief Display modulated symbols
     */</span>
    <span class="keyword">void</span> <span class="function">displaySymbols</span>(
        <span class="keyword">const</span> <span class="type">string</span>&amp; bits,
        <span class="keyword">const</span> <span class="type">vector</span>&lt;<span class="type">complex</span>&lt;<span class="type">double</span>&gt;&gt;&amp; symbols
    ) {
        cout &lt;&lt; <span class="string">"
Input Bits: "</span> &lt;&lt; bits &lt;&lt; <span class="string">"

"</span>;
        cout &lt;&lt; <span class="string">"Modulated Symbols:
"</span>;
        cout &lt;&lt; <span class="function">fixed</span> &lt;&lt; <span class="function">setprecision</span>(<span class="number">4</span>);
        
        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; symbols.<span class="function">size</span>(); i++) {
            <span class="type">string</span> dibit = bits.<span class="function">substr</span>(i*<span class="number">2</span>, <span class="number">2</span>);
            cout &lt;&lt; <span class="string">"Symbol "</span> &lt;&lt; (i+<span class="number">1</span>) &lt;&lt; <span class="string">": ["</span> &lt;&lt; dibit &lt;&lt; <span class="string">"] → ("</span>
                 &lt;&lt; symbols[i].<span class="function">real</span>() &lt;&lt; <span class="string">", "</span> &lt;&lt; symbols[i].<span class="function">imag</span>() &lt;&lt; <span class="string">"j) | "</span>
                 &lt;&lt; <span class="string">"Magnitude: "</span> &lt;&lt; <span class="function">abs</span>(symbols[i]) &lt;&lt; <span class="string">"
"</span>;
        }
    }
    
    <span class="comment">/**
     * @brief Calculate average symbol power
     */</span>
    <span class="type">double</span> <span class="function">calculateAveragePower</span>(<span class="keyword">const</span> <span class="type">vector</span>&lt;<span class="type">complex</span>&lt;<span class="type">double</span>&gt;&gt;&amp; symbols) {
        <span class="type">double</span> totalPower = <span class="number">0.0</span>;
        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; sym : symbols) {
            totalPower += <span class="function">norm</span>(sym);  <span class="comment">// |symbol|^2</span>
        }
        <span class="keyword">return</span> totalPower / symbols.<span class="function">size</span>();
    }

<span class="keyword">private</span>:
    <span class="comment">/**
     * @brief Generate Gaussian random variable (Box-Muller transform)
     */</span>
    <span class="type">double</span> <span class="function">gaussianRandom</span>(<span class="type">double</span> mean, <span class="type">double</span> variance) {
        <span class="keyword">static</span> <span class="type">bool</span> hasSpare = <span class="keyword">false</span>;
        <span class="keyword">static</span> <span class="type">double</span> spare;
        
        <span class="keyword">if</span> (hasSpare) {
            hasSpare = <span class="keyword">false</span>;
            <span class="keyword">return</span> mean + <span class="function">sqrt</span>(variance) * spare;
        }
        
        hasSpare = <span class="keyword">true</span>;
        <span class="keyword">static</span> <span class="type">double</span> u, v, s;
        <span class="keyword">do</span> {
            u = (<span class="type">double</span>)<span class="function">rand</span>() / RAND_MAX * <span class="number">2.0</span> - <span class="number">1.0</span>;
            v = (<span class="type">double</span>)<span class="function">rand</span>() / RAND_MAX * <span class="number">2.0</span> - <span class="number">1.0</span>;
            s = u * u + v * v;
        } <span class="keyword">while</span> (s &gt;= <span class="number">1.0</span> || s == <span class="number">0.0</span>);
        
        s = <span class="function">sqrt</span>(-<span class="number">2.0</span> * <span class="function">log</span>(s) / s);
        spare = v * s;
        <span class="keyword">return</span> mean + <span class="function">sqrt</span>(variance) * u * s;
    }
};

<span class="comment">/**
 * @brief Main function - Demonstration of QPSK Modulation
 */</span>
<span class="type">int</span> <span class="function">main</span>() {
    cout &lt;&lt; <span class="string">"========================================
"</span>;
    cout &lt;&lt; <span class="string">"  5G NR QPSK Modulator Demo
"</span>;
    cout &lt;&lt; <span class="string">"========================================

"</span>;
    
    <span class="comment">// Create QPSK modulator</span>
    <span class="type">QPSKModulator</span> modulator;
    
    <span class="comment">// Display constellation</span>
    modulator.<span class="function">displayConstellation</span>();
    
    <span class="comment">// Test data</span>
    <span class="type">string</span> inputBits = <span class="string">"11001001"</span>;
    
    <span class="comment">// Modulate</span>
    <span class="type">vector</span>&lt;<span class="type">complex</span>&lt;<span class="type">double</span>&gt;&gt; txSymbols = modulator.<span class="function">modulate</span>(inputBits);
    
    <span class="comment">// Display results</span>
    modulator.<span class="function">displaySymbols</span>(inputBits, txSymbols);
    
    <span class="comment">// Calculate average power</span>
    <span class="type">double</span> avgPower = modulator.<span class="function">calculateAveragePower</span>(txSymbols);
    cout &lt;&lt; <span class="string">"
Average Symbol Power: "</span> &lt;&lt; avgPower &lt;&lt; <span class="string">"
"</span>;
    
    <span class="comment">// Demodulate</span>
    <span class="type">string</span> rxBits = modulator.<span class="function">demodulate</span>(txSymbols);
    cout &lt;&lt; <span class="string">"
Demodulated Bits: "</span> &lt;&lt; rxBits &lt;&lt; <span class="string">"
"</span>;
    
    <span class="comment">// Verify</span>
    <span class="keyword">if</span> (inputBits == rxBits) {
        cout &lt;&lt; <span class="string">"✓ Modulation/Demodulation SUCCESSFUL!
"</span>;
    } <span class="keyword">else</span> {
        cout &lt;&lt; <span class="string">"✗ Error in modulation/demodulation
"</span>;
    }
    
    <span class="comment">// BER Performance Analysis</span>
    cout &lt;&lt; <span class="string">"

========================================
"</span>;
    cout &lt;&lt; <span class="string">"  BER Performance Analysis
"</span>;
    cout &lt;&lt; <span class="string">"========================================
"</span>;
    cout &lt;&lt; <span class="function">fixed</span> &lt;&lt; <span class="function">setprecision</span>(<span class="number">6</span>);
    
    <span class="type">vector</span>&lt;<span class="type">double</span>&gt; EbN0_dB = {<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>};
    
    cout &lt;&lt; <span class="string">"
Eb/N0 (dB)  | Theoretical BER
"</span>;
    cout &lt;&lt; <span class="string">"------------|----------------
"</span>;
    
    <span class="keyword">for</span> (<span class="type">double</span> snr : EbN0_dB) {
        <span class="type">double</span> ber = modulator.<span class="function">theoreticalBER</span>(snr);
        cout &lt;&lt; <span class="function">setw</span>(<span class="number">11</span>) &lt;&lt; snr &lt;&lt; <span class="string">" | "</span> &lt;&lt; ber &lt;&lt; <span class="string">"
"</span>;
    }
    
    cout &lt;&lt; <span class="string">"

Demo completed successfully!
"</span>;
    
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>
            </div>
        </div>

        <div class="highlight-box">
            <h4><i class="fas fa-lightbulb"></i> Implementation Highlights</h4>
            <p>
                This C++ implementation demonstrates a production-ready QPSK modulator with key features: (1) Gray-coded constellation mapping following 3GPP specifications, (2) Maximum likelihood demodulation for optimal BER performance, (3) AWGN channel simulation with Gaussian noise generation, (4) Theoretical BER calculation using Q-function approximation, and (5) Symbol power normalization for unit average power. The modulator uses complex arithmetic for I/Q representation and includes comprehensive error checking and validation.
            </p>
        </div>
    </section>

    <!-- Comparison Table -->
    <section class="section">
        <div class="section-header">
            <i class="fas fa-balance-scale"></i>
            <h2>QPSK vs Other Modulation Schemes</h2>
        </div>

        <div class="info-card">
            <h3><i class="fas fa-table"></i> Modulation Comparison</h3>
            <table>
                <thead>
                    <tr>
                        <th>Modulation</th>
                        <th>Bits/Symbol</th>
                        <th>Constellation Points</th>
                        <th>Spectral Efficiency</th>
                        <th>SNR Required (10^-6 BER)</th>
                        <th>Use Case in 5G</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>BPSK</strong></td>
                        <td>1</td>
                        <td>2</td>
                        <td>1 bits/Hz</td>
                        <td>~10.5 dB</td>
                        <td>Legacy systems</td>
                    </tr>
                    <tr style="background: rgba(59, 130, 246, 0.1);">
                        <td><strong>QPSK</strong></td>
                        <td>2</td>
                        <td>4</td>
                        <td>2 bits/Hz</td>
                        <td>~13.5 dB</td>
                        <td>Control, Cell edge, URLLC</td>
                    </tr>
                    <tr>
                        <td><strong>16-QAM</strong></td>
                        <td>4</td>
                        <td>16</td>
                        <td>4 bits/Hz</td>
                        <td>~18 dB</td>
                        <td>Urban eMBB, Good SNR</td>
                    </tr>
                    <tr>
                        <td><strong>64-QAM</strong></td>
                        <td>6</td>
                        <td>64</td>
                        <td>6 bits/Hz</td>
                        <td>~22 dB</td>
                        <td>High throughput eMBB</td>
                    </tr>
                    <tr>
                        <td><strong>256-QAM</strong></td>
                        <td>8</td>
                        <td>256</td>
                        <td>8 bits/Hz</td>
                        <td>~26 dB</td>
                        <td>Peak throughput, LOS</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </section>

    <!-- Applications -->
    <section class="section">
        <div class="section-header">
            <i class="fas fa-rocket"></i>
            <h2>QPSK Applications in 5G NR</h2>
        </div>

        <div class="grid-3">
            <div class="feature-card">
                <i class="fas fa-cog"></i>
                <h4>Control Channels</h4>
                <p>PDCCH, PUCCH, and other control signaling use QPSK for robust transmission of critical scheduling and feedback information even in poor channel conditions.</p>
            </div>

            <div class="feature-card">
                <i class="fas fa-broadcast-tower"></i>
                <h4>Synchronization</h4>
                <p>PSS, SSS, and PBCH employ QPSK for initial cell acquisition and broadcast information, ensuring reliable network access for all UE devices.</p>
            </div>

            <div class="feature-card">
                <i class="fas fa-user-clock"></i>
                <h4>Cell Edge Users</h4>
                <p>PDSCH/PUSCH data transmission for users with low SINR, maintaining connectivity and minimum data rates in challenging RF environments.</p>
            </div>

            <div class="feature-card">
                <i class="fas fa-industry"></i>
                <h4>URLLC Services</h4>
                <p>Ultra-reliable communications for industrial automation and mission-critical applications where link reliability takes priority over peak throughput.</p>
            </div>

            <div class="feature-card">
                <i class="fas fa-mobile-alt"></i>
                <h4>High Mobility</h4>
                <p>Maintains link quality for high-speed trains and vehicular communications where Doppler spread and rapid channel variations occur.</p>
            </div>

            <div class="feature-card">
                <i class="fas fa-satellite-dish"></i>
                <h4>IoT / mMTC</h4>
                <p>Massive IoT deployments with extended coverage requirements, enabling battery-efficient operation with sufficient data rates for sensor data.</p>
            </div>
        </div>
    </section>

    <!-- Warning Box -->
    <section class="section">
        <div class="warning-box">
            <h4><i class="fas fa-exclamation-triangle"></i> Performance Considerations</h4>
            <p>
                While QPSK offers excellent robustness, it provides lower spectral efficiency compared to higher-order modulation schemes. In 5G NR, the scheduler dynamically selects between QPSK and higher modulation orders (16/64/256-QAM) based on real-time channel quality indicators (CQI). QPSK is automatically selected when the signal-to-interference-plus-noise ratio (SINR) falls below approximately 10 dB. Engineers must balance throughput requirements against link reliability when configuring modulation and coding schemes (MCS) in radio resource management algorithms. Additionally, QPSK's constant envelope property makes it ideal for power amplifier efficiency but requires careful frequency and phase synchronization at the receiver to avoid performance degradation.
            </p>
        </div>
    </section>

</div>

<footer>
<h3>Designed By Group 3</h3>
</footer>

<script>
    // Draw QPSK Constellation Diagram
    function drawConstellation() {
        const canvas = document.getElementById('constellationCanvas');
        const ctx = canvas.getContext('2d');
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const scale = 150;
        
        // Clear canvas
        ctx.fillStyle = '#0a0e27';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw grid
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 1;
        for (let i = -2; i <= 2; i++) {
            // Vertical lines
            ctx.beginPath();
            ctx.moveTo(centerX + i * scale, 50);
            ctx.lineTo(centerX + i * scale, canvas.height - 50);
            ctx.stroke();
            
            // Horizontal lines
            ctx.beginPath();
            ctx.moveTo(50, centerY + i * scale);
            ctx.lineTo(canvas.width - 50, centerY + i * scale);
            ctx.stroke();
        }
        
        // Draw axes
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 2;
        
        // I-axis
        ctx.beginPath();
        ctx.moveTo(50, centerY);
        ctx.lineTo(canvas.width - 50, centerY);
        ctx.stroke();
        
        // Q-axis
        ctx.beginPath();
        ctx.moveTo(centerX, 50);
        ctx.lineTo(centerX, canvas.height - 50);
        ctx.stroke();
        
        // Axis labels
        ctx.fillStyle = '#94a3b8';
        ctx.font = 'bold 16px Inter';
        ctx.fillText('I (In-Phase)', canvas.width - 100, centerY - 10);
        ctx.fillText('Q (Quadrature)', centerX + 10, 70);
        
        // QPSK constellation points
        const norm = 1 / Math.sqrt(2);
        const points = [
            { x: norm, y: norm, bits: '00', angle: '45°' },      // First quadrant
            { x: -norm, y: norm, bits: '01', angle: '135°' },    // Second quadrant
            { x: norm, y: -norm, bits: '10', angle: '315°' },    // Fourth quadrant
            { x: -norm, y: -norm, bits: '11', angle: '225°' }    // Third quadrant
        ];
        
        const colors = ['#3b82f6', '#06b6d4', '#14b8a6', '#a855f7'];
        
        points.forEach((point, index) => {
            const px = centerX + point.x * scale * 1.5;
            const py = centerY - point.y * scale * 1.5;
            
            // Draw line from origin
            ctx.strokeStyle = colors[index];
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(px, py);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw point
            ctx.fillStyle = colors[index];
            ctx.beginPath();
            ctx.arc(px, py, 12, 0, 2 * Math.PI);
            ctx.fill();
            
            // Inner glow
            ctx.beginPath();
            ctx.arc(px, py, 20, 0, 2 * Math.PI);
            const gradient = ctx.createRadialGradient(px, py, 12, px, py, 20);
            gradient.addColorStop(0, colors[index] + '80');
            gradient.addColorStop(1, colors[index] + '00');
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Label
            ctx.fillStyle = '#f8fafc';
            ctx.font = 'bold 14px JetBrains Mono';
            ctx.fillText(point.bits, px - 15, py - 25);
            ctx.font = '12px Inter';
            ctx.fillStyle = '#94a3b8';
            ctx.fillText(point.angle, px - 20, py + 40);
        });
        
        // Draw unit circle
        ctx.strokeStyle = 'rgba(59, 130, 246, 0.3)';
        ctx.lineWidth = 2;
        ctx.setLineDash([10, 10]);
        ctx.beginPath();
        ctx.arc(centerX, centerY, scale * 1.5, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    // Draw I/Q Waveforms
    function drawWaveform() {
        const canvas = document.getElementById('waveformCanvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        
        // Clear canvas
        ctx.fillStyle = '#0a0e27';
        ctx.fillRect(0, 0, width, height);
        
        // Sample bit sequence: 11 00 10 01
        const bitSequence = '11001001';
        const symbolsPerBit = 50;
        const amplitude = 60;
        
        // Draw I-channel
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 3;
        ctx.beginPath();
        
        for (let i = 0; i < bitSequence.length; i += 2) {
            const dibit = bitSequence.substr(i, 2);
            let iValue = 0;
            
            if (dibit === '00' || dibit === '10') iValue = 1;
            else iValue = -1;
            
            const x1 = (i / 2) * symbolsPerBit * 2;
            const x2 = ((i / 2) + 1) * symbolsPerBit * 2;
            const y = height / 4 - iValue * amplitude;
            
            if (i === 0) ctx.moveTo(x1, y);
            ctx.lineTo(x1, y);
            ctx.lineTo(x2, y);
        }
        ctx.stroke();
        
        // I-channel label
        ctx.fillStyle = '#3b82f6';
        ctx.font = 'bold 16px Inter';
        ctx.fillText('I (In-Phase) Channel', 20, 30);
        
        // Draw Q-channel
        ctx.strokeStyle = '#14b8a6';
        ctx.lineWidth = 3;
        ctx.beginPath();
        
        for (let i = 0; i < bitSequence.length; i += 2) {
            const dibit = bitSequence.substr(i, 2);
            let qValue = 0;
            
            if (dibit === '00' || dibit === '01') qValue = 1;
            else qValue = -1;
            
            const x1 = (i / 2) * symbolsPerBit * 2;
            const x2 = ((i / 2) + 1) * symbolsPerBit * 2;
            const y = (3 * height / 4) - qValue * amplitude;
            
            if (i === 0) ctx.moveTo(x1, y);
            ctx.lineTo(x1, y);
            ctx.lineTo(x2, y);
        }
        ctx.stroke();
        
        // Q-channel label
        ctx.fillStyle = '#14b8a6';
        ctx.font = 'bold 16px Inter';
        ctx.fillText('Q (Quadrature) Channel', 20, height / 2 + 30);
        
        // Draw bit labels
        ctx.fillStyle = '#94a3b8';
        ctx.font = '12px JetBrains Mono';
        for (let i = 0; i < bitSequence.length; i += 2) {
            const dibit = bitSequence.substr(i, 2);
            const x = (i / 2) * symbolsPerBit * 2 + symbolsPerBit;
            ctx.fillText(dibit, x - 10, height - 10);
        }
        
        // Draw reference lines
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        
        // I-channel center
        ctx.beginPath();
        ctx.moveTo(0, height / 4);
        ctx.lineTo(width, height / 4);
        ctx.stroke();
        
        // Q-channel center
        ctx.beginPath();
        ctx.moveTo(0, 3 * height / 4);
        ctx.lineTo(width, 3 * height / 4);
        ctx.stroke();
        
        ctx.setLineDash([]);
    }
    
    // Interactive QPSK Modulator
    function modulateQPSK() {
        const input = document.getElementById('binaryInput').value;
        const output = document.getElementById('modulationOutput');
        
        // Validate input
        if (!/^[01]+$/.test(input)) {
            output.innerHTML = '<span style="color: #ef4444;">❌ Error: Input must contain only 0 and 1</span>';
            return;
        }
        
        if (input.length === 0) {
            output.innerHTML = '<span style="color: #f59e0b;">⚠️ Warning: Please enter binary data</span>';
            return;
        }
        
        // Pad if odd length
        let bits = input;
        if (bits.length % 2 !== 0) {
            bits += '0';
            output.innerHTML = '<span style="color: #f59e0b;">⚠️ Padded with 0 (odd length)</span><br><br>';
        } else {
            output.innerHTML = '';
        }
        
        // QPSK mapping
        const norm = 1 / Math.sqrt(2);
        const mapping = {
            '00': { i: norm, q: norm, phase: '45°' },
            '01': { i: -norm, q: norm, phase: '135°' },
            '10': { i: norm, q: -norm, phase: '315°' },
            '11': { i: -norm, q: -norm, phase: '225°' }
        };
        
        output.innerHTML += '<span style="color: #22c55e; font-weight: bold;">✓ Modulation Successful!</span><br><br>';
        output.innerHTML += `<span style="color: #3b82f6;">Input: ${input} ${input.length % 2 !== 0 ? '→ ' + bits : ''}</span><br>`;
        output.innerHTML += `<span style="color: #06b6d4;">Symbols: ${bits.length / 2}</span><br><br>`;
        
        // Display symbols
        for (let i = 0; i < bits.length; i += 2) {
            const dibit = bits.substr(i, 2);
            const symbol = mapping[dibit];
            
            output.innerHTML += `<div style="background: rgba(59,130,246,0.1); padding: 10px; margin: 5px 0; border-radius: 8px; border-left: 3px solid #3b82f6;">`;
            output.innerHTML += `<span style="color: #f8fafc; font-weight: bold;">Symbol ${(i/2) + 1}:</span> `;
            output.innerHTML += `Bits=[${dibit}] → (${symbol.i.toFixed(4)}, ${symbol.q.toFixed(4)}j) | Phase=${symbol.phase}`;
            output.innerHTML += `</div>`;
        }
    }
    
    // Initialize on page load
    document.addEventListener('DOMContentLoaded', () => {
        drawConstellation();
        drawWaveform();
        
        // Allow Enter key to trigger modulation
        document.getElementById('binaryInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                modulateQPSK();
            }
        });
    });
    
    // Redraw on window resize
    window.addEventListener('resize', () => {
        drawConstellation();
        drawWaveform();
    });
</script>

</body>
</html>
